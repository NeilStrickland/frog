<?php

require_once('frog.inc');

class frog_object_editor {
 var $frog;
 var $object_type;
 var $object;
 var $commands;
 var $command;
 var $params;

 function __construct($frog,$ot) {
  $this->frog = $frog;
  $this->object_type = $ot;

  /* The list below specifies the commands that can be executed
   * by this class.  It may be overridden by subclasses.
   * 
   * 'display' should generate a page showing information about 
   *   a specified object, with no facility to edit that information.
   *   As well as information about the object itself, the page may 
   *   display information about associated objects (eg, teaching 
   *   events and recommended books for a module occurrence).  The
   *   associated_lists() method and related methods are provided
   *   to streamline this kind of thing.  The object to be displayed
   *   is usually specified by a CGI parameter named id.  However,
   *   it is sometimes specified in other ways, as discussed below
   *   in relation with the get_params() method.
   *
   * 'load' should load information about an object from the database
   *   and generate a page that allows for editing of that information.
   *   Again, the page may allow for display or editing of various
   *   objects associated with the specified object, as well as the 
   *   specified object itself.
   * 
   * 'suggest_delete' should generate a page asking for confirmation
   *   that a specified object should be deleted.
   * 
   * 'delete' should delete a specified object, and then use 
   *   header("Location: ...") to redirect to some other page, which 
   *   will usually list the remaining 'siblings' of the deleted object.
   *   The page in question is specified by the after_delete_url()
   *   method.
   *
   * 'save' should save information given by the CGI parameters in the
   *   database.  Usually an existing object will be specified by the
   *   id parameter (or some other means), and the information for that
   *   object will be updated.  If the id parameter is blank or zero
   *   then a new object will be created and inserted in the database.
   *
   * 'new' should generate a page similar to that generated by 'load',
   *   in which the user can enter information for a new object.  The
   *   object will not actually be inserted in the database until the
   *   object editor has been invoked again with command = 'save'.
   */
  $this->commands = 
   array('display' => true,
	 'load' => true,
	 'suggest_delete' => true,
	 'delete' => true,
	 'save' => true,
	 'new' => true
	 );
 }

 /* The associated_lists() method can be overridden by subclasses.
  * This is most easily explained by example.  Every committee
  * has some members and ex-officio members, which are stored
  * as rows in the committee_memberships and 
  * ex_officio_memberships tables, linked to the committee via
  * the committee_id columns in those tables.  If $x is the PHP object
  * representing the committee then we want to set
  * $x->members to the array of members of the committee, and
  * $x->officers to the array of ex-officio members, and in 
  * appropriate places we want to make changes in the database to
  * reflect changes in $x->members and $x->officers.  This is
  * set up by overriding associated_lists() to return an array
  * like this:
  *
  * array(
  *  array('name' => 'officer',
  *        'type' => 'ex_officio_membership'),
  *  array('name' => 'member',
  *	   'type' => 'committee_membership')
  *  )
  *
  * Note that the names and types are singular.  If the type is the
  * same as the name then it can be omitted.
  *
  * The code allows for some slightly more complicated entries in
  * the list.  The only case in use at the time of writing is as
  * follows:
  *
  *    array(
  *     array('name' => 'member',
  *           'type' => 'research_group_membership',
  *           'link' => 'group_id',
  *           'filter' => research_group_membership::$is_current)
  *    )
  */
 function associated_lists() {
  return(array());
 }

 /* This can be overriden to check whether the user has permission
  * to edit the relevant object.  When this method is invoked,
  * details of the user are stored in $cfg->user, which is an
  * object of class person.  Partial details of the object to
  * be edited are in $this->object.
  */
 function check_authorisation() {
  return(1);
 }

 /* The parent_table() method can be overridden by subclasses.
  * This is most easily explained by example.  Every 
  * conference registration must be linked (via the conference_id
  * column) to a conference.  If we load an existing registration
  * from the database then the conference_id will already be set
  * and we do not need to treat this column any differently from
  * the other columns.  However, if the conference_registration_editor
  * class is used to create a new registration then it should check
  * that the request specifies the relevant conference.  To arrange
  * this we override the parent_table() method to return the 
  * string 'conference'.
  */
 function parent_table() {
  return(null);
 }

 /* Normally the run() method expects that the id of the object to
  * be edited will be given as a CGI parameter, and will complain if
  * it is missing.  For some kinds of objects, we may want to specify
  * the object in a different way, for example by giving a student's
  * registration number or email address.  For such cases we can 
  * override the try_alternate_keys() method.  This should examine the
  * CGI parameters and return the id of the relevant object if possible,
  * or return null on failure.
  */
 function try_alternate_keys() {
  return(null);
 }

 /* The get_params() method sets $this->command to the command to 
  * be executed.
  *
  * In most cases it also sets $this->object to be a  
  * nearly blank object of the relevant type with $this->object->id
  * set to the id of the object to be edited (which should be supplied
  * as a CGI parameter), and all other fields empty (or set to default
  * values).
  *
  * In a few cases, the objects we are interested in are not identified
  * by a numeric id, but by some other information.  For example,
  * modules are identified by a code such as MAS123.  The stuff about
  * $tbl->primary_key and so on is to handle that sort of case.
  *
  * Students are usually identified by a numeric id, but for some
  * purposes it is useful to be able to provide a link to student 
  * information pages that uses the email address or registration 
  * number instead of the id.  The call to try_alternate_keys() covers
  * this sort of situation.
  *
  * It can also happen that no object is specified by any of the above
  * mechanisms, because the command parameter is set to 'new' and we 
  * need to construct a new object rather than working with an existing
  * one.
  *
  * Even if an existing object has been specified, we do not fill in 
  * any information about it from the database or the CGI parameters
  * at this stage, apart from the id number or other identifier.
  *
  * There is one exception to the above, in the case where there is a
  * parent table.  In that case, if we are working with an existing
  * object, we retrieve the parent object from the database and attach
  * it to $this->object.  If we are constructing a new object, we 
  * instead expect to see the id of the parent object specified by
  * a CGI parameter, and we again retrieve the parent object from the
  * database.
  */
 function get_params() {
  $tbl = $this->frog->load_table($this->object_type);
  $o = $this->frog->new_object($this->object_type);
  $this->object = $o;
  $pk = $tbl->primary_key;
  $o->primary_key_name = $pk;
  $o->primary_key = null;

  $this->command = $this->frog->get_safe_optional_parameter('command','load');
  
  if (! (isset($this->commands[$this->command])
	 && $this->commands[$this->command])) {
   error_page('Invalid command');
   exit;
  }

  if ($this->command == 'new') {
   $t = $this->parent_table();
   if ($t) {
    $tid = $t . '_id';
    $o->$tid = (int) get_required_parameter($tid);
    $o->$t = $this->frog->load($t,$o->$tid);
    if (! $o->$t) {
     error_page("Could not load $t with id=$tid");
     exit;
    }
   }
  } else {
   $id = $this->frog->get_safe_optional_parameter($pk,'');
   if ($tbl->primary_key_type == 'integer') {
    $id = (int) $id;
   }

   $o->primary_key_name = $pk;
   $o->primary_key = $id;
   $o->$pk = $id;

   if (($this->command != 'save') && ! $o->$pk) {
    $o->$pk = $this->try_alternate_keys();
    if (! $o->$pk) {
     error_page('No key supplied');
     exit;
    }
   }

   $t = $this->parent_table();
   if($t && $o->id) {
    $id = $o->id;
    $tid = $t . '_id';
    $tbl = $this->frog->load_table($this->object_type);
    $q = "SELECT $tid FROM tbl_{$tbl->name_plural} WHERE id={$id}";
    $o->$tid = (int) $this->frog->get_answer($q);
    $o->$t = $this->frog->load($t,$o->$tid);
    if (! $o->$t) {
     error_page("Could not load $t with id=$tid");
     exit;
    }
   }
  }
 }

 /* The load_from_database() method assumes that $this->object has been
  * set to an object of the required type that may be mostly blank but 
  * at least has the id field (or equivalent) filled in.  That means that
  * remaining information about the object can be retrieved by invoking
  * $this->object->load().  
  *
  * In cases where there is a parent table, we then try to retrieve the
  * parent object of $this->object, unless that has already been done.
  * It probably has been done by the get_params() method, so this block
  * of code may be redundant; but perhaps there are exceptional cases that
  * I have forgotten.
  *
  * After loading information about $this->object itself, we load
  * information from the database about other associated objects.
  */
 function load_from_database() {
  $o = $this->object;
  $x = $o->load();
  if (! $x) {
   error_page("Object not found ({$this->object_type},{$this->object->primary_key})");
   return(0);
  }

  $t = $this->parent_table();
  if ($t) {
   $tid = $t . '_id';
   if ($o->$tid && ! (isset($o->$t) && $o->$t)) {
    $o->$t = $this->frog->load($t,$o->$tid);
    if (! $o->$t) {
     error_page("Could not load $t with id=$tid");
     exit;
    }
   }
  }

  $aa = $this->associated_lists();

  foreach ($aa as $a) {
   // Currently there do not seem to be any cases where we use
   // the mechanism below.
   if (isset($a['no_database_load']) && $a['no_database_load']) {
    continue;
   }

   $this->load_associated_list_from_database($a);
  }

  return(1);
 }

 function load_associated_list_from_database($a) {
  $o = $this->object;

  if (! ($o && $o->id)) { return(null); }

  $name = $a['name'];
  $plural = $name . 's';
  $type = $name;
  $link = "x.{$this->object_type}_id";
  if (isset($a['type'])) { $type = $a['type']; }
  if (isset($a['plural'])) { $plural = $a['plural']; }
  if (isset($a['link'])) { $link = $a['link']; }
  $table = $this->frog->load_table($type);
  $link_clause = "{$link}={$o->id}";
  if (isset($a['filter'])) {
   $link_clause .= ' AND ' . $a['filter'];
  }
  $o->$plural = $this->frog->load_where($type,$link_clause);
 }

 /* The load_from_request method fills in fields in 
  * $this->object from the CGI parameters.  If CGI parameters for
  * some fields are missing, then the corresponding members of
  * $this->object will be left unset.  This means that if we later
  * invoke $this->object->save(), then the corresponding database
  * columns will be left as they are.
  */
 function load_from_request() {
  $this->object->fill_from_request();
 }

 function load_associated_lists_from_request() {
  foreach ($this->associated_lists() as $a) {
   // Currently there do not seem to be any cases where we use
   // the mechanism below.
   if (isset($a['no_request_load']) && $a['no_request_load']) {
    continue;
   }

   $this->load_associated_list_from_request($a);
  }
 }

 /* In this method, the argument $a is an element of the array
  * returned by the associated_lists() method.  As a typical
  * example, in the object editor for module 
  * occurrences, $a could be array('name' => 'book').  In that
  * case, this method will assume that $this->object->books has
  * already been set to a list of recommended books for the module 
  * occurrence stored as $this->object.  If one of those books has
  * id 1234, then this method will look for CGI parameters like
  * book_1234_title, and use them to change the information stored
  * in the database for book 1234.  
  *
  * Note that there is a difference here between the
  * load_from_request() method, which only changes information 
  * about the module occurrence in PHP's memory, and the
  * load_associated_lists_from_request() method, which immediately
  * saves changes to books in the database.  I think that there is
  * a good reason for this but I do not remember it.
  * 
  * The load_associated_lists_from_request() also looks for CGI 
  * parameters like remove_book_1234.  If that parameter is present,
  * then book 1234 will be deleted from the database and also 
  * from the array $this->object->books()
  *
  * The load_associated_lists_from_request() also looks for CGI 
  * parameters like add_book_1_title, add_book_2_title and so on.
  * If these are present then new book objects will be constructed
  * using the values of these parameters, and they will be added to
  * the database and to the array $this->object->books(), except
  * that we do not add new books if all the fields are empty.
  */
 function load_associated_list_from_request($a) {
  $o = $this->object;

  if (! ($o && $o->id)) { return(null); }

  $name = $a['name'];
  $plural = $name . 's';
  $type = $name;
  $link = "{$this->object_type}_id";
  if (isset($a['type'])) { $type = $a['type']; }
  if (isset($a['plural'])) { $plural = $a['plural']; }
  if (isset($a['link'])) { $link = $a['link']; }
  $table = $this->frog->load_table($type);
  $link_clause = "{$link}={$o->id}";

  $new_entries = array();

  foreach($o->$plural as $e) {
   $k = $e->set_prefix($name);
   if (isset($_REQUEST['remove_' . $k])) {
    $e->delete(1);
   } else {
    $e->changed = $e->fill_from_request($k . '_');
    if ($e->changed) { $e->save(); }
    $new_entries[] = $e;
   }
  }

  $max_new = 10;
  for ($i = 0; $i < $max_new; $i++) {
   $k = "add_{$name}_{$i}";
   if (isset($_REQUEST[$k])) {
    $y = $this->frog->new_object($type);
    $y->fill_from_request($k . '_');
    if (! $y->is_empty()) {
     $y->$link = $o->id;
     $y->insert();
     $y->load();
     $new_entries[] = $y;
    }
   }
  }

  $o->$plural = $new_entries;
 }

 /* The save_in_database() method saves information about 
  * $this->object in the database.  Note that if any members 
  * of $this->object are unset, then the corresponding values in
  * the database will be left unchanged.
  *
  * Note also that we do not save information about associated
  * objects, because that was already done by 
  * load_associated_list_from_request().
  *
  * In most cases, the save() method is inherited from the
  * frog_object class and just saves information in the 
  * database.  A few subclasses of frog_object override the
  * save method and perform additional tasks.
  */
 function save_in_database() {
  $this->object->save();
 }

 function h1_logo() {
  $logo = '';
  if (isset($this->frog->nav) && $this->frog->nav) {
    $nav = $this->frog->nav;
    if (isset($nav->h1_logo)) {
      $logo = $nav->h1_logo;
    }
  }
  return $logo;
 }

 /* The delete_object() method deletes $this->object from the
  * database.  A few subclasses of frog_object override the
  * delete method and perform additional tasks.
  *
  * Usually (but not always) one wants to delete associated 
  * objects at the same time as deleting $this->object.  This is
  * handled by various ad hoc mechanisms, which should probably
  * be consolidated.
  */
 function delete_object() {
  $this->object->delete();
 }

 /* This should be overridden to return 1 for editors that need
  * to be able to process uploaded files.
  */
 function allow_upload() {
  return 0;
 }

 function confirm_delete_page() {
  global $cfg;

  $ttl = $this->confirm_delete_title();
  $msg = $this->confirm_delete_message();
  $can = $this->on_cancel_string();
  
  $this->frog->nav->header($ttl);
  $here = $_SERVER['SCRIPT_NAME'];

  $o = $this->object;
  
  echo <<<HTML

<h1>{$this->h1_logo()} $ttl</h1>
<br/>
<p class="text">
$msg
</p>
<br/>
<form name="main_form" action="$here" method="POST">
<input type="hidden" name="{$o->primary_key_name}" value="{$o->primary_key}"/>
<input type="hidden" name="command" value="load"/>

<table>
 <tr>
  <td class="command" width="100" onclick="frog.do_command('delete')">Confirm</td>
  <td class="command" width="100" onclick="$can">Cancel</td>
 </tr>
</table>
</form>

HTML;

  $this->frog->nav->footer(); 

 }

 function confirm_delete_title() {
  return('Confirm deletion of ' . $this->object_type);
 }

 function confirm_delete_message() {
  $d = $this->object->descriptor();

  $msg = <<<HTML
Do you really want to delete this object: $d?

HTML;

  return($msg);
 }

 /* The listing_url() method returns the url of a page that lists
  * the siblings of $this->object.  The editing page will usually
  * have a link marked 'Index' to that listing page.  The meaning
  * of 'sibling' depends on context, and subclasses of the 
  * object_editor class may override the listing_url() method
  * accordingly.
  */
 function listing_url() {
  return($this->object_type . '_list.php');
 }

 /* The after_delete_url() method returns the url of a page to which
  * we redirect after performing a deletion.
  */
 function after_delete_url() {
  return($this->listing_url());
 }
 
 function on_cancel_string() {
    return('frog.do_command(\'load\')');
 }

 // This method returns text to be used in an <h1> element.
 function edit_page_title() {
  if ($this->command == 'new') {
   return('New ' . $this->object_type);
  } else {
   $t = $this->object->descriptor();
   if ($this->command == 'clone') {
    $t .= ' (copy)';
   }
   return($t);
  }
 }

 // This method returns text to be used in a <title> element.
 // Usually this will be the same as in the <h1> element; however,
 // the <h1> element can contain HTML markup but the <title>
 // element should not.
 function edit_page_raw_title() {
  return($this->edit_page_title());
 }

 function edit_page_scripts() {
  global $cfg;

  $d = dirname($_SERVER['SCRIPT_FILENAME']);
  $f = basename($_SERVER['SCRIPT_FILENAME'],'.php');
  $s = array();

  foreach(array('frog','objects_auto',$this->frog->name,$f) as $e) {
   if (file_exists($d . '/js/' . $e . '.js')) {
    $s[] = $e;
   }
  }

  return $s;
 }

 function edit_page_styles() {
  global $cfg;

  $d = dirname($_SERVER['SCRIPT_FILENAME']);
  $f = basename($_SERVER['SCRIPT_FILENAME'],'.php');

  if (file_exists($d . '/' . $f . '.css')) {
   return(array($f));
  } else {
   return(array());
  }
 }

 function edit_page_widgets() {
  return(array('tabber','autosuggest'));
 }

 function edit_page_onload() {
  return '';
 }

 function edit_page_command_bar() {
  $html = <<<HTML
<table>
 <tr>
  <td id="save_td" class="command" width="100" onclick="frog.do_command('save');">Save</td>
  <td id="load_td" class="command" width="100" onclick="frog.do_command('load');">Restore</td>

HTML;

  if (isset($this->commands['suggest_delete'])) {
   $html .= <<<HTML
  <td id="suggest_delete_td" class="command" width="100" onclick="frog.do_command('suggest_delete');">Delete</td>

HTML;
  }

  $u = $this->listing_url();
  if ($u) {
   $html .= <<<HTML
  <td id="listing_td" class="command" width="100" onclick="location='$u';">Index</td>

HTML;
  }

  $html .= <<<HTML
 </tr>
</table>

HTML;

  return $html;
 }

 function edit_page_header() {
  global $cfg;
  $t = $this->edit_page_title();
  $here = $_SERVER['SCRIPT_NAME'];
  $nav = $this->frog->nav;
  
  $nav->header($this->edit_page_raw_title(),
   array(
    'widgets' => $this->edit_page_widgets(),
    'scripts' => $this->edit_page_scripts(),
    'styles' => $this->edit_page_styles(),
    'onload' => $this->edit_page_onload()
   )
  );

  $enc = $this->allow_upload() ? 'enctype="multipart/form-data"' : '';
  
  echo <<<HTML
<h1>{$this->h1_logo()} $t</h1>

<form name="main_form" action="$here" $enc method="POST">
<input type="hidden" name="id" value="{$this->object->id}"/>
<input type="hidden" name="command" value="load"/>

HTML;

  $t = $this->parent_table();
  if ($t) {
   $tid = $t . '_id';
   $i = $this->object->$tid;
  echo <<<HTML
<input type="hidden" name="{$tid}" value="$i"/>

HTML;
  }

  echo $this->edit_page_command_bar();
 }

 function extra_forms() {
  return '';
 }

 function edit_page_footer() {
  echo <<<HTML
</form>

HTML;

  echo $this->extra_forms();

  $this->frog->nav->footer();
 }

 function edit_page() {
  error_page("Editing is not implemented for objects of type {$this->object_type}");
 }

 function display_page_title() {
  return($this->object->descriptor());
 }

 function display_page_styles() {
  return(array());
 }

 function display_page_scripts() {
  global $cfg;

  $d = dirname($_SERVER['SCRIPT_FILENAME']);
  $s = array();

  foreach(array('frog','objects_auto',$this->frog->name) as $e) {
   if (file_exists($d . '/js/' . $e . '.js')) {
    $s[] = $e;
   }
  }

  return $s;
 }

 function display_page_widgets() {
  return(array('tabber','autosuggest'));
 }

 function display_page_onload() {
  return '';
 }

 function display_page_command_bar() {
  echo <<<HTML
<table>
 <tr>

HTML;

  $u = $this->listing_url();
  if ($u) {
   echo <<<HTML
  <td class="command" width="100" onclick="location='$u';">Index</td>

HTML;
  }

  echo <<<HTML
 </tr>
</table>

HTML;


 }

 function display_page_header() {
  global $cfg;
  $t = $this->display_page_title();

  if (! $t) { $t = $this->edit_page_title(); }

  $this->frog->nav->header(
   $t,
   array(
    'widgets' => $this->display_page_widgets(),
    'scripts' => $this->display_page_scripts(),
    'styles' => $this->display_page_styles(),
    'onload' => $this->display_page_onload()
   )
  );

  echo <<<HTML
<h1>{$this->h1_logo()} $t</h1>

HTML;

  $this->display_page_command_bar();
 }

 function display_page() {
  error_page("Display is not implemented for objects of type {$this->object_type}");
 }

 function display_page_footer() {
  $this->frog->nav->footer();
 }

 function redirect_after_save_url() {
  return 
   $_SERVER['SCRIPT_NAME'] . '?id=' . $this->object->id;
 }

 function run() {
  $this->get_params();
  $this->load_from_request();
  if (! $this->check_authorisation()) {
   error_page('Not authorised');
   exit;
  }
  $command = $this->command;
  if ($command == 'display') {
   if ($this->load_from_database()) {
    $this->display_page();
   }
  } elseif ($command == 'load') {
   if ($this->load_from_database()) {
    $this->edit_page();
   }
  } elseif ($command == 'clone') {
   if ($this->load_from_database()) {
    $this->object->id = null;
    $this->edit_page();
   }
  } elseif ($command == 'suggest_delete') {
   if ($this->load_from_database()) {
    $this->confirm_delete_page();
   }
  } elseif ($command =='delete') {
   if ($this->object->id) {
    $this->object->load();
   }
   
   $url = $this->after_delete_url();

   if ($this->object->id) {
    $this->delete_object();
   }
   header("Location: " . $url);
  } elseif ($command == 'save') {
   $this->save_in_database();
   $this->load_from_database();
   $this->load_associated_lists_from_request();
   $url = $this->redirect_after_save_url();
   if ($url) {
    header('Location:' . $url);
   } else {
    $this->load_from_database();
    $this->edit_page();
   }
  } elseif ($command == 'new') {
   $this->edit_page();
  } else {
   $this->handle_command();
  }
 }

 function handle_command() {
  // This method should be extended in any context where one needs
  // to handle command other than those in the standard list.
 }
};

?>
